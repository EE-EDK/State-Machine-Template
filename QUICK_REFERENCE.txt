/**
 * QUICK REFERENCE GUIDE
 * State Machine Framework - Common Operations
 * ==========================================
 */

/*---------------------------------------------------------------------------
 * INITIALIZATION
 *---------------------------------------------------------------------------*/

// Basic initialization
if (!App_Main_Init()) {
    // Handle failure
}

// Custom debug interface initialization
Debug_Init(COMM_INTERFACE_SPI);  // Use SPI instead of UART

// Configure debug messages
Debug_EnableInitMessages(false);     // Disable init messages
Debug_EnableRuntimeMessages(true);   // Enable runtime messages
Debug_EnablePeriodicMessages(true);  // Enable periodic status


/*---------------------------------------------------------------------------
 * STATE MACHINE OPERATIONS
 *---------------------------------------------------------------------------*/

// Execute state machine (call in main loop)
App_Main_Task();

// Post an event to trigger state transition
StateMachine_PostEvent(EVENT_START);
StateMachine_PostEvent(EVENT_DATA_READY);
StateMachine_PostEvent(EVENT_STOP);

// Query current state
StateMachineState_t current = StateMachine_GetCurrentState();
if (current == STATE_ACTIVE) {
    // Do something based on current state
}

// Get previous state (useful in transition logic)
StateMachineState_t previous = StateMachine_GetPreviousState();

// Reset state machine (returns to INIT)
StateMachine_Reset();


/*---------------------------------------------------------------------------
 * ERROR HANDLING
 *---------------------------------------------------------------------------*/

// Report a minor error (auto-recovery)
ErrorHandler_Report(ERROR_LEVEL_MINOR, ERROR_CODE_COMM_LOST);

// Report a normal error (managed recovery)
ErrorHandler_Report(ERROR_LEVEL_NORMAL, ERROR_CODE_TIMEOUT);

// Report a critical error (system lock)
ErrorHandler_Report(ERROR_LEVEL_CRITICAL, ERROR_CODE_HARDWARE_FAULT);

// Check for critical error lock
if (ErrorHandler_IsCriticalLock()) {
    // System is locked - requires reset
}

// Get current error information
ErrorInfo_t error;
if (ErrorHandler_GetCurrentError(&error)) {
    // Use error information
    // error.level, error.code, error.retry_count, etc.
}

// Clear error after manual recovery
ErrorHandler_ClearError();


/*---------------------------------------------------------------------------
 * DEBUG MESSAGING
 *---------------------------------------------------------------------------*/

// Send different types of debug messages
Debug_SendMessage(DEBUG_MSG_INIT, "System initialized");
Debug_SendMessage(DEBUG_MSG_RUNTIME, "Processing %d samples", count);
Debug_SendMessage(DEBUG_MSG_ERROR, "Error: %s", ErrorCodeToString(code));
Debug_SendMessage(DEBUG_MSG_WARNING, "Low battery: %d%%", battery_level);
Debug_SendMessage(DEBUG_MSG_INFO, "Temperature: %dC", temp);

// Change debug interface at runtime
Debug_SetInterface(COMM_INTERFACE_I2C);

// Periodic messages are automatic - just enable them
Debug_EnablePeriodicMessages(true);


/*---------------------------------------------------------------------------
 * POSTING EVENTS FROM INTERRUPTS
 *---------------------------------------------------------------------------*/

// From GPIO interrupt
void EXTI0_IRQHandler(void) {
    if (/* button pressed */) {
        StateMachine_PostEvent(EVENT_START);
    }
    // Clear interrupt flag
}

// From timer interrupt
void TIM2_IRQHandler(void) {
    if (/* data ready */) {
        StateMachine_PostEvent(EVENT_DATA_READY);
    }
    // Clear interrupt flag
}

// From DMA complete interrupt
void DMA1_Stream0_IRQHandler(void) {
    if (/* transfer complete */) {
        StateMachine_PostEvent(EVENT_PROCESSING_DONE);
    }
    // Clear interrupt flag
}


/*---------------------------------------------------------------------------
 * COMMON PATTERNS
 *---------------------------------------------------------------------------*/

// Pattern 1: Wait for specific state
void WaitForIdle(void) {
    while (StateMachine_GetCurrentState() != STATE_IDLE) {
        App_Main_Task();
        HAL_Delay(10);
    }
}

// Pattern 2: Trigger processing sequence
void TriggerDataProcessing(void) {
    // Must be in ACTIVE or MONITORING state
    StateMachine_PostEvent(EVENT_DATA_READY);
}

// Pattern 3: Safe shutdown sequence
void SafeShutdown(void) {
    // Return to idle first
    StateMachine_PostEvent(EVENT_STOP);
    
    // Wait for idle
    uint32_t timeout = GetCurrentTimeMs() + 5000;
    while (StateMachine_GetCurrentState() != STATE_IDLE) {
        App_Main_Task();
        if (GetCurrentTimeMs() > timeout) {
            // Force reset if timeout
            StateMachine_Reset();
            break;
        }
    }
}

// Pattern 4: Check and report errors
void MonitorSystem(void) {
    if (temperature > MAX_TEMP) {
        ErrorHandler_Report(ERROR_LEVEL_NORMAL, ERROR_CODE_HARDWARE_FAULT);
    }
    
    if (battery_voltage < MIN_VOLTAGE) {
        ErrorHandler_Report(ERROR_LEVEL_CRITICAL, ERROR_CODE_HARDWARE_FAULT);
    }
    
    if (comm_packet_lost) {
        ErrorHandler_Report(ERROR_LEVEL_MINOR, ERROR_CODE_COMM_LOST);
    }
}


/*---------------------------------------------------------------------------
 * TIMING UTILITIES
 *---------------------------------------------------------------------------*/

// Check for timeout
uint32_t start_time = GetCurrentTimeMs();
// ... do something ...
if (IsTimeout(start_time, 1000)) {
    // 1 second has elapsed
}

// Simple delay (blocking - avoid in state callbacks)
uint32_t delay_start = GetCurrentTimeMs();
while (!IsTimeout(delay_start, 100)) {
    // Wait 100ms
}


/*---------------------------------------------------------------------------
 * STRING CONVERSION
 *---------------------------------------------------------------------------*/

// Convert state to string for debugging
const char* state_name = StateToString(STATE_PROCESSING);
// Returns: "PROCESSING"

// Convert error code to string
const char* error_name = ErrorCodeToString(ERROR_CODE_TIMEOUT);
// Returns: "TIMEOUT"

// Use in debug messages
Debug_SendMessage(DEBUG_MSG_INFO, "State: %s, Error: %s",
                 StateToString(StateMachine_GetCurrentState()),
                 ErrorCodeToString(current_error.code));


/*---------------------------------------------------------------------------
 * INTEGRATION EXAMPLES
 *---------------------------------------------------------------------------*/

// Example 1: Bare metal main loop (STM32)
int main(void) {
    HAL_Init();
    SystemClock_Config();
    
    App_Main_Init();
    
    while (1) {
        App_Main_Task();
        HAL_Delay(10);  // Match SM_TASK_PERIOD_MS
    }
}

// Example 2: FreeRTOS task
void AppTask(void *pvParameters) {
    const TickType_t xPeriod = pdMS_TO_TICKS(10);
    TickType_t xLastWakeTime = xTaskGetTickCount();
    
    App_Main_Init();
    
    while (1) {
        App_Main_Task();
        vTaskDelayUntil(&xLastWakeTime, xPeriod);
    }
}

// Example 3: With watchdog
int main(void) {
    HAL_Init();
    MX_IWDG_Init();  // Initialize watchdog
    
    App_Main_Init();
    
    while (1) {
        App_Main_Task();
        HAL_IWDG_Refresh(&hiwdg);  // Feed watchdog
        HAL_Delay(10);
    }
}


/*---------------------------------------------------------------------------
 * DEBUGGING TIPS
 *---------------------------------------------------------------------------*/

// Tip 1: Enable only needed messages in production
#define DEBUG_ENABLE_INIT_MESSAGES      (0U)  // OFF in production
#define DEBUG_ENABLE_RUNTIME_MESSAGES   (0U)  // OFF in production
#define DEBUG_ENABLE_PERIODIC_MESSAGES  (1U)  // Keep for monitoring

// Tip 2: Use periodic messages to monitor health
// Automatically prints every DEBUG_PERIODIC_INTERVAL_MS:
// "[timestamp] Status: State=ACTIVE, Executions=1234"

// Tip 3: Check state transitions
Debug_SendMessage(DEBUG_MSG_INFO, "Requesting transition to PROCESSING");
StateMachine_PostEvent(EVENT_DATA_READY);
// Next execution will show: "State transition: ACTIVE -> PROCESSING"

// Tip 4: Monitor error history
ErrorInfo_t error;
if (ErrorHandler_GetCurrentError(&error)) {
    Debug_SendMessage(DEBUG_MSG_ERROR, 
                     "Active Error: %s (attempts: %d, recovered: %d)",
                     ErrorCodeToString(error.code),
                     error.retry_count,
                     error.is_recovered);
}


/*---------------------------------------------------------------------------
 * PERFORMANCE TUNING
 *---------------------------------------------------------------------------*/

// For fast response systems:
#define SM_TASK_PERIOD_MS               (1U)   // 1ms execution period

// For battery-powered systems:
#define SM_TASK_PERIOD_MS               (100U) // 100ms execution period
#define FEATURE_LOW_POWER_ENABLED       (1U)   // Enter sleep in IDLE

// For reliable systems:
#define ERROR_MAX_RECOVERY_ATTEMPTS     (5U)   // More recovery attempts
#define ERROR_HISTORY_SIZE              (32U)  // Larger error history

// For memory-constrained systems:
#define ERROR_HISTORY_SIZE              (4U)   // Smaller history
#define DEBUG_MAX_MESSAGE_LENGTH        (64U)  // Shorter messages
#define DEBUG_ENABLE_RUNTIME_MESSAGES   (0U)   // Disable verbose messages


/*---------------------------------------------------------------------------
 * COMMON ERROR SCENARIOS
 *---------------------------------------------------------------------------*/

// Scenario 1: Communication timeout
// 1. Report normal error
ErrorHandler_Report(ERROR_LEVEL_NORMAL, ERROR_CODE_TIMEOUT);
// 2. State machine transitions to RECOVERY
// 3. Attempts recovery up to ERROR_MAX_RECOVERY_ATTEMPTS times
// 4. If successful: Returns to IDLE
// 5. If failed: Escalates to CRITICAL_ERROR

// Scenario 2: Lost packet during communication
// 1. Report minor error
ErrorHandler_Report(ERROR_LEVEL_MINOR, ERROR_CODE_COMM_LOST);
// 2. System attempts to verify channel (3 good messages in 50ms)
// 3. If successful: Auto-recovery, continue operation
// 4. If failed: Escalates to normal error

// Scenario 3: Hardware fault detected
// 1. Report critical error immediately
ErrorHandler_Report(ERROR_LEVEL_CRITICAL, ERROR_CODE_HARDWARE_FAULT);
// 2. System immediately transitions to CRITICAL_ERROR state
// 3. All outputs disabled, system locked
// 4. Requires manual reset or watchdog timeout


/*---------------------------------------------------------------------------
 * CUSTOM STATE IMPLEMENTATION TEMPLATE
 *---------------------------------------------------------------------------*/

// 1. Add state to enum in app_main.h
// typedef enum {
//     ...
//     STATE_MY_CUSTOM_STATE,
//     STATE_MAX
// } StateMachineState_t;

// 2. Add event to trigger transition (if needed)
// typedef enum {
//     ...
//     EVENT_MY_CUSTOM_EVENT,
//     EVENT_MAX
// } StateMachineEvent_t;

// 3. Implement callbacks in app_main.c
static void State_MyCustom_OnEntry(void) {
    Debug_SendMessage(DEBUG_MSG_RUNTIME, "Entering custom state");
    // Initialize state resources
}

static void State_MyCustom_OnState(void) {
    // Execute state logic
    if (/* condition met */) {
        StateMachine_PostEvent(EVENT_PROCESSING_DONE);
    }
}

static void State_MyCustom_OnExit(void) {
    Debug_SendMessage(DEBUG_MSG_RUNTIME, "Exiting custom state");
    // Clean up resources
}

// 4. Add to InitializeStateTable() in app_main.c
// g_state_table[STATE_MY_CUSTOM_STATE].state_id = STATE_MY_CUSTOM_STATE;
// g_state_table[STATE_MY_CUSTOM_STATE].on_entry = State_MyCustom_OnEntry;
// g_state_table[STATE_MY_CUSTOM_STATE].on_state = State_MyCustom_OnState;
// g_state_table[STATE_MY_CUSTOM_STATE].on_exit = State_MyCustom_OnExit;
// g_state_table[STATE_MY_CUSTOM_STATE].timeout_ms = 2000U;
// g_state_table[STATE_MY_CUSTOM_STATE].transitions[0] = 
//     (StateTransition_t){EVENT_PROCESSING_DONE, STATE_ACTIVE};
// g_state_table[STATE_MY_CUSTOM_STATE].transition_count = 1;


/*---------------------------------------------------------------------------
 * FREQUENTLY ASKED QUESTIONS
 *---------------------------------------------------------------------------*/

// Q: Can I call StateMachine_PostEvent() from an interrupt?
// A: Yes! Event posting is designed to be atomic and ISR-safe.

// Q: What happens if I post an event while one is pending?
// A: The new event is dropped and a warning is logged. Only one 
//    pending event is allowed to ensure deterministic behavior.

// Q: Can state callbacks block (use delays)?
// A: NO! State callbacks must be non-blocking. Use timeouts and 
//    execution counts instead.

// Q: How do I implement a delay in a state?
// A: Use execution count or time checks:
//    if (g_sm_context.state_execution_count > 10) { /* 10 cycles */ }
//    if (IsTimeout(g_sm_context.state_entry_time, 1000)) { /* 1s */ }

// Q: Can I transition directly between states?
// A: No, always use StateMachine_PostEvent(). Direct transitions
//    bypass the proper OnEntry/OnExit callback execution.

// Q: How do I recover from CRITICAL_ERROR state?
// A: Critical errors require manual intervention - either a 
//    hardware reset or watchdog timeout. This is by design.

// Q: Can I add more than 10 states?
// A: Yes, increase SM_MAX_STATES in app_main.h and add your 
//    state configurations to InitializeStateTable().

// Q: How do I change debug output at runtime?
// A: Use Debug_SetInterface(COMM_INTERFACE_xxx) to switch between
//    UART, SPI, and I2C interfaces.


/*---------------------------------------------------------------------------
 * END OF QUICK REFERENCE
 *---------------------------------------------------------------------------*/
